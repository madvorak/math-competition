import data.real.basic


theorem must_be_identity {f : ℝ → ℝ} (h : ∀ x y : ℝ,
      f (f x + (y + 1) / (f y)) = 1 / (f y) + x + 1) :
  ∀ x : ℝ,  x > 0  →  f x = x  :=
begin
  let A : ℝ := 1 / f 1 + 1,
  have high_range : ∀ B : ℝ, B > A → (∃ z : ℝ, f z = B),
  {
    intros B B_gt_A,
    let x := B - A,
    have equ := h x 1,
    use f x + 2 / f 1,
    rw one_add_one_eq_two at equ,
    rw equ,
    change 1 / f 1 + (B - (1 / f 1 + 1)) + 1 = B,
    --have xpos : B - (1 / f 1 + 1) > 0, sorry,
    convert_to 1 / f 1 + B - (1 / f 1 + 1) + 1 = B, sorry,
    convert_to 1 / f 1 + B - (1 / f 1) - 1 + 1 = B, sorry,
    convert_to 1 / f 1 + B - (1 / f 1) + 1 - 1 = B, sorry,
    convert_to 1 / f 1 + B - (1 / f 1) + 0 = B, sorry,
    convert_to 1 / f 1 + B - (1 / f 1) = B, rw add_zero,
    finish,
  },
  have inj_f : function.injective f,
  {
    intros a b fa_eq_fb,
    have foo : ∀ c : ℝ, 1 / (f c) + a + 1 = 1 / (f c) + b + 1,
    {
      intro c,
      rw ← h a c,
      rw ← h b c,
      rw fa_eq_fb,
    },
    finish,
  },

  have lin_on_rat : ∀ p q : ℕ, let x : ℝ := ↑p / ↑q in
      f x = f 1 + (x - 1) * (f 2 - f 1),
  {
    intros p q,
    sorry,
  },
  have increasing_f :  ∀ x y : ℝ,  0 < x  →  x < y  →  f x < f y,
  {
    sorry,
  },
  have lin_on_real : ∀ x : ℝ, f x = f 1 + (x - 1) * (f 2 - f 1),
  {
    intro x,
    sorry,
  },

  have degree_one : ∃ a b : ℝ, ∀ x : ℝ, f x = a * x + b,
  {
    use f 2 - f 1,
    use f 1 + f 1 - f 2,
    intro x,
    rw lin_on_real x,
    ring,
  },
  rcases degree_one with ⟨a, b, hf⟩,
  have a_eq_1 : a = 1,
  {
    specialize h 1 1,
    repeat { rw hf at h },
    rw mul_one at h,
    rw mul_add at h,
    rw mul_add at h,
    have multiplied := congr_arg (λ v, (a + b) * v) h,
    dsimp at multiplied,
    rw mul_add (a + b) _ 1 at multiplied,
    rw mul_add (a + b) _ 1 at multiplied,
    rw mul_div (a + b) 1 (a + b) at multiplied,
    rw mul_comm (a + b) 1 at multiplied,
    repeat { rw one_mul at multiplied },
    rw div_self at multiplied,
    repeat { rw mul_add (a + b) at multiplied },
    rw ← mul_assoc (a + b) a ((1 + 1) / (a + b)) at multiplied,
    rw mul_div at multiplied,
    rw mul_comm (a + b) a at multiplied,
    rw mul_assoc at multiplied,
    rw mul_comm (a + b) (1 + 1) at multiplied,
    rw ← mul_div at multiplied,
    rw ← mul_div at multiplied,
    rw div_self at multiplied,
    rw mul_one at multiplied,
    have subtracted := congr_arg (λ v, v - 2 * a) multiplied,
    dsimp at subtracted,
    ring_nf at subtracted,
    sorry, sorry, sorry,
  },
  have b_eq_0 : b = 0,
  {
    rw a_eq_1 at hf,
    sorry,
  },

  intros x xpos,
  rw hf x,
  rw a_eq_1,
  rw b_eq_0,
  rw add_zero,
  rw one_mul,
end
